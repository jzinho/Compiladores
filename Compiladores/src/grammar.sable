Package compilador ; 
     
Helpers
   any_char      = [0x0 .. 0xfff];
   digito        = ['0' .. '9'];
   letra       = [['a' .. 'z'] + ['A' .. 'Z']];
   id = letra letra*;
   num = digito digito*;
   cr  = 13;
   lf  = 10;
   tab = 9;
   eol = cr lf | cr | lf;
   branco = (' ' | tab | eol)+;
   //integer = digito; 
   not_star = [any_char - '*'];
   not_star_slash = [not_star - '/'];
   
  
Tokens 
   //Identificadores
  blank   = branco;
  string = 'string';
  int = 'int';
  integer_number = digito;
  t_id = id;
  t_num = num;
  comment_line = '//'[any_char - [lf + cr]]*;
  comment_block = '/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/';
  if ='if';
  else ='else';
  return = 'return';
  void = 'void';
  while = 'while';
  
  //Símbolos
  open_brace = '{';
  close_brace = '}';
  lsbrack = '[';
  rsbrack = ']';
  lpar = '(';
  rpar = ')';
  comma  = ',';
  scolon   = ';';
  atrib = ':=';
  colon = ':';
  div = '/';
  plus  = '+';
  minus = '-';
  times = '*';
  mod = '%';
  greater = '>';
  less = '<';
  gequal = '>=';
  lequal = '<=';
  not = '!';
  and = 'and';
  or = 'or';
  xor = 'xor';
  diff   = '!=';
  equal    = '=';
  equalequal    = '==';
  identifier = letra ( digito | letra )*;
    
Ignored Tokens
comment_line,
blank,
comment_block;

Productions

program = {decl_list} decl_list;

decl_list = {sequence}decl_list decl|
            {single} decl;

decl = {variable} var_decl |
       {function} fun_decl;

var_decl = type_decl var_decl_id scolon;

type_decl = {int} integer_number |
            {void} void;
            
var_decl_id = {id} t_id |
              {bracks} t_id lsbrack t_num rsbrack;
              

fun_decl = {type} type_decl t_id lpar params rpar statement |
           {notype} t_id lpar params rpar statement ;

params = {p_list} param_list |
         {empty};

param_list= {p_listparam}param_list scolon param_type |
            {param} param_type ;

param_type = {type_decl} type_decl param_id_list;

param_id_list = {idlist}param_id_list comma param_id |
                {paramid}param_id;

param_id = {without}t_id |
           {with}t_id lsbrack rsbrack ;
           
//Statement

statement = {expression}expression_stmt |
            {compound}compound_stmt |
            {selection}selection_stmt |
            {iteration}iteration_stmt |
            {return}return_stmt;
            
statement_else = {selse}selection_stmt_else |
                 {expression}expression_stmt |
                 {return}return_stmt |
                 {compound}compound_stmt   ;   
                 
              //   {iteration}iteration_stmt  ;   

expression_stmt= expression scolon |
                 {scolon}scolon;

statement_list = statement_list statement |
                 {empty};                 
                 
compound_stmt = open_brace local_declaration statement_list close_brace ; 

        

selection_stmt = {if}if lpar simple_expression rpar statement |
                 {ifelse}if lpar simple_expression rpar statement_else else statement;
                 
selection_stmt_else = {ifelse}if lpar simple_expression rpar statement_else else statement_else2;                 

              
                 
statement_else2 = statement_else;                         

iteration_stmt = while lpar simple_expression rpar statement;

return_stmt =  {return1} return scolon |
               {return2}return expression scolon;

expression = {comparation} mutable equal expression |
             {add}simple_expression;

local_declaration = local_declaration var_decl |
                     {empty};

simple_expression = {a1} add_exp rel_op add_exp2|
                    {single} add_exp;
                    
add_exp2 = add_exp;                   
                    
add_exp = {addterm}add_exp add_op term |
          {term} term;                  


term = {termfactor}term mult_op factor |
       {factor}factor;
       
factor = {mul}mutable |
         {imul}immutable;


mutable = {single}t_id |
      {idexpression}t_id lsbrack expression rsbrack;
      
immutable = {expression} lpar expression rpar |
            {call} call| 
            {num} t_num;      
      
call = t_id lpar args rpar;

args = args_list | {empty};

args_list = {listargs}args_list comma expression |
            {expression}expression;      

rel_op =  {diff} diff |
          {equal} equalequal |
          {greater} greater |
          {less} less |
          {gequal} gequal |
          {lequal} lequal ;

add_op =  {plus} plus |
          {minus} minus ;

mult_op = {times} times |
          {div} div |
          {mod} mod;

